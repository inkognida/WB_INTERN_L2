package main

import "fmt"

/*
	Реализовать паттерн «посетитель».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Visitor_pattern

Паттерн "Посетитель" (Visitor) является поведенческим паттерном проектирования,
который позволяет добавлять новые операции к объектам без изменения их классов. Он разделяет алгоритмы от объектов,
над которыми они работают, и позволяет добавлять новые операции без изменения существующих классов.

Применимость паттерна "Посетитель":
Когда у вас есть сложная структура объектов с разными типами и требуется выполнять различные операции над ними, не изменяя классы объектов.
Когда необходимо добавить новые операции к объектам без изменения существующей иерархии классов.

Преимущества использования паттерна "Посетитель":
Расширяемость: Паттерн позволяет легко добавлять новые операции, добавляя новые посетителей, без изменения существующих классов объектов.
Чистота кода: Код операций размещается в отдельных классах-посетителях, что делает его более читаемым, понятным и поддерживаемым.
Разделение ответственностей: Операции над объектами вынесены в отдельные классы-посетители,
что способствует более гибкой структуре и разделению ответственностей между классами.

Недостатки использования паттерна "Посетитель":
Усложнение структуры программы: Внедрение паттерна "Посетитель" может привести к увеличению количества классов и усложнению структуры программы.
Нарушение инкапсуляции: Посетитель может требовать доступа к внутренним данным объекта, что нарушает принцип инкапсуляции.
Пример использования паттерна "Посетитель" на практике (на языке Golang) может быть в обработке различных типов элементов коллекции:
*/


// Realization интерфейс функционала для покупателя
type Realization interface {
	MakeDesign(e *AppA)
	MakeSoft(e *AppB)
}

// Element интерфейс приложения
type Element interface {
	 Accept(f Realization)
}

// AppA приложение A
type AppA struct {

}

func (a *AppA) Accept(r Realization) {
	r.MakeDesign(a)
}

// AppB приложение B
type AppB struct {

}

func (b *AppB) Accept(r Realization) {
	r.MakeSoft(b)
}

// Buyer покупатель
type Buyer struct {
	ID int
}

func (b *Buyer) MakeDesign(a *AppA) {
	fmt.Println("App a", b.ID)
}

func (b *Buyer) MakeSoft(ba *AppB) {
	fmt.Println("App b", b.ID)
}


func main() {
	// создаем элементы (приложения)
	elements := []Element{&AppA{}, &AppB{}}

	// создаем покупателей
	buyers := []*Buyer{&Buyer{ID: 1}, &Buyer{ID: 2}}

	// выполняем операцию над элементов для каждого посетителя
	for _, e := range elements {
		e.Accept(buyers[0])
		e.Accept(buyers[1])
	}
}